\chapter{Implementation}

    For this project the design and implementation were very closely related
    and the implementation frequently affected design choices and vice versa.
    Despite this, there were a few details that did not affect the overall
    design. This chapter explores those bits.


    \section{FUSE module}

        Linux Kernel development is a notoriously difficult and time consuming
        process, as evidenced by the many guides on the topic
        \cite{https://kernelnewbies.org/KernelDevViewpoint},
        \cite{https://www.kernel.org/doc/html/v4.16/process/howto.html}. Even
        trivial changes to it frequently take days to implement and big
        projects, such as a filesystem, cover a very wide range of topics that
        \textit{must} be considered for the end result to be functional. Things
        such as concurrency, memory limitations, kernel API intricacies,
        caching and so on. To avoid the risk of getting bogged down with them
        and running out of time to implement the project, the decision to stay
        in userspace was made.

        The advantage is that most of these details are either handled for the
        programmer by either the kernel or the standard library or can be
        safely ignored. For example, memory is managed by the simple
        \syscall{malloc} and \syscall{free} in the standard library while
        concurrency can be ignored because by defualt the environment is single
        threaded. Further, a userspace implementation allows the product to be
        packaged and distributed for a much wider selection of kernels. It is
        widely known that the kernel does not maintain a stable API between
        versions
        \cite{https://elixir.bootlin.com/linux/v5.18-rc1/source/Documentation/process/stable-api-nonsense.rst}.
        This means that for compatibility with more than one version of the
        kernel the module has to be rebuilt (and potentially edited) upon each
        release. The alternative to this, of course, is upstreaming the module
        as a driver in the Linux kernel itself. However, this is vastly out of
        scope for this project, ignoring the likelyhood of such a major feature
        being ever accepted. Building this project in userspace solves this, as
        all userspace APIs are guaranteed stability \cite{we do not break
        userspace} and standard libraries follow this rule.

        The disadadvantage of this approach is a loss of efficiency. There are
        two factors at play: the kernel-userspace transitions and the lack of
        integration with the kernel. The kernel-userspace transitions are an
        overhead (so much so that there are specific features to minimise their
        occurances such as vDSO
        \cite{https://man7.org/linux/man-pages/man7/vdso.7.html}) that however
        small is measurable and adds up
        \cite{https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/}.
        The lack of integration is primarily in caching and memory allocation.
        As a consequence, computations will take longer because they will not
        be explicitly cached, instead realying only on what the kernel's
        caching policy might be for arbitrary data, potentially being
        suboptimal. Binaries will be larger and allocate more memory at runtime
        because they will share less code with the kernel (although this will
        be partially mitigated by shared libraries
        \cite{https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html})
        and will use a separate memory address space and allocator which
        prevents from optimising memory usage with the kernel and making memory
        fragmentation more likely.

        All things considered, opting for a userspace implementation for this
        project is the best option. Especially since a minimal implementation
        is desired and this choice drastically simplifies the code and reduces
        development time which reduces risk.

        The particular mechanism of implementing the filesystem in userspace is
        the aptly named FUSE (Filesystems in USErspace) framework
        \cite{https://www.kernel.org/doc/html/latest/filesystems/fuse.html}. It
        provides a kernel interface specifically for implementing filesystems
        as well as a userspace library to connect to it with very little code.
        This is the only native Linux kernel framework for this and since this
        is a Linux project the choice is made fur us.

    \section{Filesystem}

    \section{Redundancy}

    \section{Bootstrap}

        Bootrstrapping a filesystem is usually done by a separate command like
        mkfs \cite{man mkfs}, leaving the filesystem in an always initialised
        state. For this project the distinction was done away with, choosing
        instead for the filesystem to do it itself. This was once again done
        for simplicity, as maintaining a separate binary takes extra makefile
        rules and a more meticulous file heirarchy. Nevertheless, all of the
        same funcionality is present and the initialion routine is very clearly
        separate from the rest of the filesystem so that there is still
        possibility of separating it without requiring major code reworks.

        To initialise the filesystem is a bit tricky as the problem is
        partially dependent on itself as writing the filesystem datastructures
        relies on having some of them present. Having a linear and static
        initialiser proved to be very difficult to maintain as it produced a
        lot of duplicate special purpose code that is, of course, prone to
        bugs. The static arrangement itself was problematic as hard coding
        block numbers to data structures was very fragile as they tended to
        change frequently as the general design evolved.

        Instead a dynamic approach was selected. To do this we (ab)use the fact
        that everything is a file (\ref{sec_files}), so normal file operation
        routines can be used at initialisation, particulary file creation and
        writing. For them to work, however, the free list needs to be present.
        Assuming a valid free list, all other bootstrap operations can be done
        with code used throughput the filesystem with clever ordering. In
        particular, the inode list must be allocated first, filled in, after
        which the root directory (\monospace{/}) can be allocated. Only caveat is
        that the block at which the inode of the inode list is stored must be
        fed back to the superblock so that its location is known to the
        filesystem, since it is th e only file that is not referenced by
        another.

        % TODO: maybe put the convention bit in the superblock chapter
        Writing the free list while done statically is done in a clever way to
        reuse as much code as possible. First, a convention is assumed: the
        superblock is stored on block 1 and the free list can immediately
        follow. So an alternate bootrstrap only allocator is put in the place
        of the filesystem allocator which returns block sequentailly starting
        from block 2. Then the free list inode and body are allocated as
        regular files. They end up fully sequential with the inode on block 2
        and the file data on blocks 3 and onward. Once this is done, the file
        is written with 1's for as many blocks as the volume on which the
        filesystem is being formatted on has with normal IO routines. After
        this is done, the free list is complete and the normmal allocator is
        put back in place.

    \section{version control and good practices?}
