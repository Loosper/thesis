Over the years UNIX like operating systems and their filesystems have gone a
long way. Numerous advances achieve very high degrees of resource utilisation
with robust and well thought out features. A major consideration throughout has
been drive unreliability. Any drive is prone to failure and even when function
may misbehave in an undetectable manner. To ensure data integrity there exist
many solutions, some better than others. Notably ext4 ensures filesystem
consistency even if data is unaccounted for while ZFS considers every
eventuality even if at the cost of substantial complexity. At the same time
simplistic solutions like arrays of disks (RAID) go a long way to provide
redundancy.

All of these solutions have problems though. Ext4 does not checksum data, RAID
has a write hole issue and ZFS is incredibly complex. This presents a challenge
for less technically savvy home users who will not be aware of the pros and
cons of each or may simple be unable to administer them.

To that effect, this project proposes a new filesystem that attempts to collect
the good things of each of these while mitigating the major issues and making
it easy to use. It integrates modern techniques for ensuring data integrity
without compromising on performance by design.  It targets the ever so
ubiquious solid state drives to optimise for what is most likely to be in the
target field of laptops, office desktops and home servers.

The proof of concept implementation achieves very good integrity. All data is
stored with full redundancy to protect against any pattern of drive
misbehaviour. Any silent data corruption can be detected with secure hashes of
all blocks and restored from the redundant copies. The result is cost and
administratively competitive with a wide variety of other solutions so it is a
valid choice.

Its performance is suboptimal due to not including extents and prototype
implementation. The penalty for the lack of extents was unexpected and further
analysis is performed to find out the cause.

Nevertheless, the basic desgn is robust enough for the filesystem to become a
usable module. It is implemented as a FUSE module to ensure portability for
widespread and easy use. The shortcomings can be addressed without major
reworks and further iteration can be performed for a full product.
